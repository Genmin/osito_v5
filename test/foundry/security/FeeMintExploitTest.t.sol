// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {BaseTest} from "../BaseTest.t.sol";
import {OsitoToken} from "../../../src/core/OsitoToken.sol";
import {OsitoPair} from "../../../src/core/OsitoPair.sol";
import {FeeRouter} from "../../../src/core/FeeRouter.sol";
import {FixedPointMathLib} from "solady/utils/FixedPointMathLib.sol";
import {console2} from "forge-std/console2.sol";
import {ERC20} from "solady/tokens/ERC20.sol";

/// @notice Tests to catch the fee-mint exploit (rootK/rootKLast issue)
/// @dev The critical bug is when fees over-mint LP tokens due to improper formula
contract FeeMintExploitTest is BaseTest {
    using FixedPointMathLib for uint256;
    
    OsitoToken public token;
    OsitoPair public pair;
    FeeRouter public feeRouter;
    
    uint256 constant SUPPLY = 1_000_000_000 * 1e18;
    uint256 constant INITIAL_LIQUIDITY = 100 ether;
    
    function setUp() public override {
        super.setUp();
        
        // Launch token with initial liquidity
        (token, pair, feeRouter) = _launchToken(
            "Test Token",
            "TEST", 
            SUPPLY,
            INITIAL_LIQUIDITY,
            alice
        );
    }
    
    /// @notice Helper to calculate expected fee mint using correct Uniswap V2 formula
    /// @dev Formula: liquidity = totalSupply * (sqrt(k) - sqrt(kLast)) / (5 * sqrt(k) + sqrt(kLast))
    function _calculateExpectedFeeMint(
        uint256 k,
        uint256 kLast,
        uint256 totalSupply
    ) internal pure returns (uint256 expectedMint) {
        if (kLast == 0 || k <= kLast) return 0;
        
        uint256 rootK = k.sqrt();
        uint256 rootKLast = kLast.sqrt();
        
        // Uniswap V2 formula for 1/6 of growth
        uint256 numerator = totalSupply * (rootK - rootKLast);
        uint256 denominator = rootK * 5 + rootKLast;
        uint256 oneSixth = numerator / denominator;
        
        // Scale to 90% (9/10 * 6 = 54/10) as per Osito implementation
        expectedMint = oneSixth * 54 / 10;
        
        return expectedMint;
    }
    
    /// @notice Test that fee minting is bounded correctly
    function test_FeeMintBounded() public {
        // Record initial state
        uint256 initialFeeRouterLP = pair.balanceOf(address(feeRouter));
        uint256 kLast = pair.kLast();
        uint256 totalSupplyBefore = pair.totalSupply();
        
        // Perform large swap to generate fees
        uint256 swapAmount = 50 ether;
        vm.startPrank(alice);
        weth.approve(address(pair), swapAmount);
        _swap(pair, address(weth), swapAmount, alice);
        vm.stopPrank();
        
        // Get new K value
        (uint112 r0, uint112 r1,) = pair.getReserves();
        uint256 k = uint256(r0) * uint256(r1);
        
        // Calculate expected fee mint
        uint256 expectedMint = _calculateExpectedFeeMint(k, kLast, totalSupplyBefore);
        
        // Trigger fee collection
        vm.prank(address(feeRouter));
        pair.collectFees();
        
        // Check actual fee mint
        uint256 actualFeeMint = pair.balanceOf(address(feeRouter)) - initialFeeRouterLP;
        
        // Assert fee mint is within 1% tolerance of expected
        assertLe(
            actualFeeMint,
            expectedMint * 101 / 100,
            "Fee mint exceeded expected by more than 1%"
        );
        
        // Also check it's not under-minting by too much
        assertGe(
            actualFeeMint,
            expectedMint * 99 / 100,
            "Fee mint is less than 99% of expected"
        );
    }
    
    /// @notice Fuzz test fee minting with random swap sizes
    function testFuzz_FeeMintBounded(uint256 swapSeed) public {
        // Bound swap size between 0.1 and 100 ETH
        uint256 swapAmount = bound(swapSeed, 0.1 ether, 100 ether);
        
        // Fund alice if needed
        if (weth.balanceOf(alice) < swapAmount) {
            deal(address(weth), alice, swapAmount);
        }
        
        // Record initial state
        uint256 initialFeeRouterLP = pair.balanceOf(address(feeRouter));
        uint256 kLast = pair.kLast();
        uint256 totalSupplyBefore = pair.totalSupply();
        
        // Perform swap
        vm.startPrank(alice);
        weth.approve(address(pair), swapAmount);
        _swap(pair, address(weth), swapAmount, alice);
        vm.stopPrank();
        
        // Get new K value
        (uint112 r0, uint112 r1,) = pair.getReserves();
        uint256 k = uint256(r0) * uint256(r1);
        
        // Calculate expected fee mint
        uint256 expectedMint = _calculateExpectedFeeMint(k, kLast, totalSupplyBefore);
        
        // Trigger fee collection
        vm.prank(address(feeRouter));
        pair.collectFees();
        
        // Check actual fee mint
        uint256 actualFeeMint = pair.balanceOf(address(feeRouter)) - initialFeeRouterLP;
        
        // Assert bounded within 2% for fuzz test (slightly more lenient)
        assertLe(
            actualFeeMint,
            expectedMint * 102 / 100,
            "Fee mint exceeded expected by more than 2%"
        );
    }
    
    /// @notice Test the specific exploit: massive swap → collect fees → check bounds
    function test_ExcessLPMintExploit() public {
        // Record initial WETH reserves
        (uint112 r0, uint112 r1,) = pair.getReserves();
        bool tokIsToken0 = pair.tokIsToken0();
        
        // Fund alice with large amount for massive swap
        uint256 attackSwapAmount = 500 ether;
        deal(address(weth), alice, attackSwapAmount);
        
        vm.startPrank(alice);
        weth.approve(address(pair), attackSwapAmount);
        
        // Record LP balance before attack
        uint256 lpBalanceBefore = pair.balanceOf(address(feeRouter));
        uint256 totalSupplyBefore = pair.totalSupply();
        
        // Execute large swap
        _swap(pair, address(weth), attackSwapAmount, alice);
        vm.stopPrank();
        
        // Collect fees (test if over-minting occurs)
        vm.prank(address(feeRouter));
        pair.collectFees();
        
        // Check LP minted
        uint256 lpMinted = pair.balanceOf(address(feeRouter)) - lpBalanceBefore;
        uint256 totalSupplyAfter = pair.totalSupply();
        
        if (lpMinted > 0 && totalSupplyBefore > 0) {
            // Calculate what percentage of total supply was minted
            uint256 mintPercentage = (lpMinted * 100) / totalSupplyBefore;
            
            // With the refactored formula, fee mint should be reasonable
            // The fix should prevent excessive minting
            assertLe(mintPercentage, 10, "Fee mint exceeds 10% - still concerning");
            
            // Additional check: Verify fee mint is proportional to K growth
            (uint112 r0After, uint112 r1After,) = pair.getReserves();
            uint256 kBefore = uint256(r0) * uint256(r1);
            uint256 kAfter = uint256(r0After) * uint256(r1After);
            
            if (kAfter > kBefore) {
                uint256 kGrowthBps = ((kAfter - kBefore) * 10000) / kBefore;
                uint256 lpMintBps = (lpMinted * 10000) / totalSupplyBefore;
                
                // LP mint should be proportional to sqrt(K) growth
                // With 90% fee capture, allow up to 2x the sqrt growth
                uint256 sqrtGrowthBps = kGrowthBps.sqrt();
                assertLe(lpMintBps, sqrtGrowthBps * 2, "LP mint disproportionate to K growth");
            }
        }
    }
    
    /// @notice Invariant: Fee mint should be proportional to actual fee value
    function testInvariant_FeeMintProportionalToValue() public {
        // Run multiple swap rounds
        for (uint i = 0; i < 10; i++) {
            uint256 swapAmount = (i + 1) * 1 ether;
            
            // Fund and swap
            deal(address(weth), bob, swapAmount);
            vm.startPrank(bob);
            weth.approve(address(pair), swapAmount);
            
            // Record state before
            uint256 kBefore = _getCurrentK();
            uint256 lpSupplyBefore = pair.totalSupply();
            uint256 feeRouterLPBefore = pair.balanceOf(address(feeRouter));
            
            // Swap
            _swap(pair, address(weth), swapAmount, bob);
            vm.stopPrank();
            
            // Record K after swap
            uint256 kAfter = _getCurrentK();
            uint256 kGrowth = kAfter > kBefore ? kAfter - kBefore : 0;
            
            // Collect fees
            vm.prank(address(feeRouter));
            pair.collectFees();
            
            uint256 lpMinted = pair.balanceOf(address(feeRouter)) - feeRouterLPBefore;
            
            if (kGrowth > 0 && lpMinted > 0) {
                // Check that LP minted is reasonable relative to K growth
                // LP minted should be roughly proportional to sqrt(k) growth
                uint256 sqrtKBefore = kBefore.sqrt();
                uint256 sqrtKAfter = kAfter.sqrt();
                uint256 sqrtGrowthBps = ((sqrtKAfter - sqrtKBefore) * 10000) / sqrtKBefore;
                
                // LP mint percentage should be less than sqrt growth percentage
                uint256 lpMintBps = (lpMinted * 10000) / lpSupplyBefore;
                
                // Allow 2x buffer for formula differences but no more
                assertLe(
                    lpMintBps,
                    sqrtGrowthBps * 2,
                    "LP mint disproportionate to K growth"
                );
            }
        }
    }
    
    /// @notice Helper to get current K value
    function _getCurrentK() internal view returns (uint256) {
        (uint112 r0, uint112 r1,) = pair.getReserves();
        return uint256(r0) * uint256(r1);
    }
}